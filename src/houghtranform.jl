

function is_binary_image{T}(img::AbstractArray{T,2})
    for pix in CartesianRange(size(img))
        if img[pix] != 0.0 && img[pix] != 1.0
            return false
        end
    end
    return true
end

"""
lines = hough_transform_standard(image, rho, theta, min_theta, max_theta, threshold, linesMax)

Returns an array of tuples corresponding to the tuples of (r,t) where r and t are parameters for normal form of line:
    x*cos(t) + y*sin(t) = r

r = length of perpendicular from (0,0) to the line
t = angle between perpendicular from (0,0) to the line and axis

The lines are generated by applying hough transform on the image.

Parameters:
    image       = image to apply hough transform on
    rho         = discrete steps for radius
    theta       = discrete steps for theta
    min_theta   = minimum theta of lines
    max_theta   = maximum theta of lines
    threshold   = no of points to pass through line for considering it valid
    linesMax    = maximum no of lines to return

"""

function hough_transform_standard{T}(
            img::AbstractArray{T,2},
            rho::Float64, theta::Float64,
            min_theta::Float64, max_theta::Float64,
            threshold::Int64, linesMax::Int64)
   
    theta > 0 || error("theta threshold must be positive")
    rho > 0 || error("radius threshold must be positive")
    min_theta < max_theta || error("max_theta must be greater than min_theta")

    if ! is_binary_image(img)
        img = canny(img)
    end

    width::Int64 = size(img)[2]
    height::Int64 = size(img)[1]
    irho::Float64 = 1 / rho;
    numangle::Int64 = round((max_theta - min_theta)/theta)
    numrho::Int64 = round(((width + height)*2 + 1)/rho)

    accumulator_matrix = Array{Int64}(numangle + 2, numrho + 2)
    fill!(accumulator_matrix, 0)

    #Pre-Computed sines and cosines in tables
    tabsin = Array{Float64}(numangle)
    tabcos = Array{Float64}(numangle)
    for i in 1:numangle
        tabsin[i] = (sin(min_theta + (i-1)*theta) * irho)
        tabcos[i] = (cos(min_theta + (i-1)*theta) * irho)
    end


    #Hough Transform implementation
    for pix in CartesianRange(size(img))
        if img[pix] == 1.0
            for i in 1:numangle
                dist::Int64 = round((pix[1] * tabsin[i] + pix[2] * tabcos[i]))
                dist += round((numrho -1)/2)
                accumulator_matrix[i + 1, dist + 1] += 1
            end
        end
    end

    #Finding local maximum lines
    validLines = Array{CartesianIndex}(0)
    for val in CartesianRange(size(accumulator_matrix))
        if  accumulator_matrix[val] > threshold &&
            accumulator_matrix[val] > accumulator_matrix[val[1],val[2] - 1] &&
            accumulator_matrix[val] >= accumulator_matrix[val[1],val[2] + 1] &&
            accumulator_matrix[val] > accumulator_matrix[val[1] - 1,val[2]] &&
            accumulator_matrix[val] >= accumulator_matrix[val[1] + 1,val[2]]
            push!(validLines,val)
        end
    end

    #Sorting by value in accumulator_matrix
    sort!(validLines, by = (x)->accumulator_matrix[x], rev = true)

    linesMax = min(linesMax, size(validLines)[1])

    lines = Array{Tuple{Float64,Float64}}(0)

    #Getting lines with Maximum value in accumulator_matrix && size(lines) < linesMax
    for l in 1:linesMax
        lrho = ((validLines[l][2]-1) - (numrho - 1)*0.5)*rho
        langle = ((validLines[l][1]-1)*theta + min_theta)
        push!(lines,(lrho,langle))
    end

    lines

end


